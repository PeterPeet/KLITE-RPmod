// Autogenerate running memory mod
let maxMemories = 5, lastContextLength = concat_gametext(true, "").length, autosummaryInterval = 60 * 1000;
let updateRunningMemory = async () => {
    if (!localsettings?.enableRunningMemory || gametext_arr.length == 0 || (gametext_arr.length == 1 && gametext_arr[0].trim() == "")) {
        return null
    } else {
        let truncated_context = concat_gametext(true, "");
        if (truncated_context.length > (lastContextLength + (0.5 * localsettings.max_context_length * 3.0))) {
            lastContextLength = truncated_context.length
            let max_allowed_characters = Math.floor(localsettings.max_context_length * 3.0) - 100;
            let max_mem_len = Math.floor(max_allowed_characters * 0.8);
            let truncated_memory = current_memory.substring(current_memory.length - max_mem_len);
            if (truncated_memory != null && truncated_memory != "") {
                truncated_memory += "\n";
            }

            truncated_context = end_trim_to_sentence(truncated_context, true);
            truncated_context = truncated_context.substring(truncated_context.length - max_allowed_characters);
            let augmented_len = truncated_memory.length + truncated_context.length;
            let excess_len = augmented_len - max_allowed_characters; //if > 0, then we exceeded context window
            truncated_context = truncated_memory + truncated_context.substring(excess_len);

            let long_story = (truncated_context.length > 1800 ? true : false);
            truncated_context += "\n{{[INPUT]}}:Summarize the above text in a single paragraph of up to " + (long_story ? "ten" : "five") + " detailed sentences.{{[OUTPUT]}}";
            truncated_context = replace_placeholders(truncated_context);

            let summary = await generateAndGetTextFromPrompt(truncated_context)
            if (!!summary) {
                let overwriteWIFromAgent = (uniqueIdentifier, content) => {
                    let baseWI = {
                        "key": "",
                        "keysecondary": "",
                        "keyanti": "",
                        "content": content,
                        "comment": uniqueIdentifier,
                        "folder": null,
                        "selective": false,
                        "constant": true,
                        "probability": "100",
                        "wigroup": "Autogenerated history",
                        "widisabled": false
                    }
                    current_wi = current_wi.filter(wi => wi?.comment !== uniqueIdentifier)
                    current_wi.push(baseWI)
                }
                let runningMemory = current_wi.filter(wi => wi?.wigroup === "Autogenerated history")
                if (runningMemory.length >= maxMemories) {
                    current_wi = current_wi.filter(wi => wi?.comment !== runningMemory[0].comment)
                }
                overwriteWIFromAgent(`AutoHist${Math.floor(Math.random() * 1000)}`, `[Autogenerated history:\n\n${summary}]`)
                return summary
            }
        }
    }
}
setInterval(updateRunningMemory, autosummaryInterval)

let previousRestartNewGame = restart_new_game, previousLoadSelectedFile = load_selected_file
restart_new_game = () => {
    previousRestartNewGame()
    lastContextLength = concat_gametext(true, "").length
}

load_selected_file = (file) => {
    previousLoadSelectedFile(file)
    lastContextLength = concat_gametext(true, "").length
}